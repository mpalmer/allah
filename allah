#!/usr/bin/env ruby
#
# A god-compatible CLI to daemontools services.

require 'etc'
require 'fileutils'

BASENAME = File.basename($0)
if BASENAME == "god"
	GOD = true
else
	GOD = false
end

RC_UP    = RC_OK  = 0
RC_DOWN  = RC_ERR = 1
RC_OTHER = 2
RC_TEMP  = 126
RC_USAGE = 127

module Allah
	# Change to the specified service dir, scan for services, and return a hash
	# with two keys:
	#
	#  - :services -- a hash of svcname => Allah::Service instances,
	#     representing the services configured; and
	#  - :groups -- a hash of groupname => Allah::Group instances, representing
	#     the groups that have been configured.
	def self.scan_services(svdir)
		rv = { :services => {}, :groups => {} }

		unless File.readable?(svdir)
			$stderr.puts "Unable to access service dir #{svdir}; do you need to run as root?"
			return nil
		end

		begin
			Dir.chdir(svdir)
		rescue SystemCallError => e
			$stderr.puts "Unable to change to service dir: #{e}"
			return nil
		end

		Dir['*'].each do |s|
			File.exists?(File.join(s, 'supervise')) or next
			svc = Allah::Service.new(s)
			rv[:services][svc.name] = svc
			groups = svc.groups
			# Make sure everyone gets into at least one group
			groups = ['(ungrouped)'] if groups.empty?
			groups.each do |g|
				(rv[:groups][g] ||= Allah::Group.new(g)) << svc
			end
		end

		return rv
	end

	class CLI
		def initialize(argv)
			@argv = argv
		end

		def run
			case @argv[0]
				when nil         then do_help
				when 'help'      then do_help
				when '--help'    then do_help
				when 'start'     then do_action(@argv[1], :start)
				when 'restart'   then do_action(@argv[1], :restart)
				when 'stop'      then do_action(@argv[1], :stop)
				when 'remove'    then do_action(@argv[1], :remove)
				when 'monitor'   then do_action(@argv[1], :monitor)
				when 'unmonitor' then do_action(@argv[1], :unmonitor)
				when 'smite'     then do_action(@argv[1], :smite)
				when 'log'       then do_log(@argv[1])
				when 'logdump'   then do_logdump(@argv[1])
				when 'status'    then do_status(@argv[1])
				when 'check'     then GOD ? 0 : do_status(@argv[1], true)
				when 'signal'    then do_signal(@argv[1], @argv[2])
				when 'create'    then do_create(@argv[1], @argv[2], (@argv[3..-1] || []).join(' '))
				when 'nuke'      then do_nuke(@argv[1])
				else
					puts "Command #{@argv[0]} is not valid. Run '#{$0} --help' for usage"
					GOD ? RC_ERR : RC_USAGE
			end
		end

		def do_help
			puts <<-EOF.gsub(/^\t{4}/, '')
				Usage:
				 #{BASENAME} <command> [arguments]

				 Commands:
					start <task or group name>         start task or group
					restart <task or group name>       restart task or group
					stop <task or group name>          stop task or group
					monitor <task or group name>       monitor task or group
					unmonitor <task or group name>     unmonitor task or group
					remove <task or group name>        remove task or group from #{BASENAME}
					log <task or group name>           show realtime log for given task
			EOF

			unless GOD
				puts <<-EOF.gsub(/^\t{4}/, '')
					logdump <task or group name>       dump *all* logs for given task
				EOF
			end

			puts <<-EOF.gsub(/^\t{3}/, '')
				status [task or group name]        show status
			EOF

			unless GOD
				puts <<-EOF.gsub(/^\t{4}/, '')
					logdump <task name>                print all log messages for task
					check [task or group name]         show status and run task checks
					smite <task or group name>         stop task or group, and make *sure* it's down
					create <task> <user> <command...>  create a new allah service
					nuke <task>                        remove an allah service, including logs
				EOF
			end

			puts <<-EOF.gsub(/^\t{3}/, '')
				signal <task or group name> <sig>  signal all matching tasks
			EOF

			return RC_OK
		end

		def do_action(svc_or_group, action)
			svclist = Allah.scan_services(svdir)
			return RC_TEMP if svclist.nil?

			ctl = svclist[:groups][svc_or_group] || svclist[:services][svc_or_group]
			if ctl.nil?
				puts "Task or Group '#{svc_or_group}' not found"
				return GOD ? RC_ERR : RC_USAGE
			end

			ctl.send(action) ? RC_OK : RC_ERR
		end

		def do_log(svc)
			if svc.nil?
				puts "You must specify a Task name"
				return GOD ? RC_ERR : RC_USAGE
			end

			svclist = Allah.scan_services(svdir)
			return RC_TEMP if svclist.nil?

			logfiles = []

			if svclist[:services][svc]
				logfiles = [svclist[:services][svc].logfile]
				if logfiles[0].nil?
					puts "Cannot find logfile for service #{svc}"
					return RC_ERR
				end
			elsif svclist[:groups][svc]
				logfiles = svclist[:groups][svc].services.map do |s|
					if s.logfile.nil?
						puts "Cannot find logfile for service #{s.name} (part of group #{svc})"
						return RC_ERR
					end
					s.logfile
				end
			else
				puts "Task '#{svc}' not found"
				return GOD ? RC_ERR : RC_USAGE
			end

			exec "tail --follow=name #{logfiles.join(' ')} | tai64nlocal"

			# This function, if successfully executed, never returns
			raise RuntimeError.new("Can't happen: dropped out the bottom of do_log")
		end

		def do_logdump(svc)
			if svc.nil?
				puts "You must specify a Task name"
				return GOD ? RC_ERR : RC_USAGE
			end

			svclist = Allah.scan_services(svdir)
			return RC_TEMP if svclist.nil?

			logfiles = []

			if svclist[:services][svc]
				logdir = File.dirname(svclist[:services][svc].logfile)
				logfiles = (Dir["#{logdir}/@*.s"] + [svclist[:services][svc].logfile]).sort
			else
				puts "Task '#{svc}' not found"
				return GOD ? RC_ERR : RC_USAGE
			end

			exec "cat #{logfiles.join ' '} | tai64nlocal"

			return RC_OK
		end

		def do_status(svc_or_group_or_nil, check = false)
			svclist = Allah.scan_services(svdir)
			return RC_TEMP if svclist.nil?

			sgn = :all
			unless svc_or_group_or_nil.nil?
				sgn = svclist[:groups][svc_or_group_or_nil] ||
						svclist[:services][svc_or_group_or_nil] ||
						nil
			end

			if sgn.nil?
				puts "Task or Group '#{svc_or_group_or_nil}' not found."
				return GOD ? RC_ERR : RC_USAGE
			elsif sgn == :all
				sts = []
				svclist[:groups].values.sort.each do |g|
					puts "#{g.name}:"
					g.services.sort.each do |s|
						st = check ? s.check : s.status
						uptime = (GOD or st != :up) ? '' : " (#{s.uptime} seconds, PID #{s.pid})"
						puts "  #{s.name}: #{st}#{uptime}"
						sts << st
					end
				end
				return RC_OK   if GOD
				return RC_UP   if sts.all? { |st| st == :up   }
				return RC_DOWN if sts.all? { |st| st == :down }
				return RC_OTHER
			elsif sgn.is_a? Allah::Group
				puts "#{sgn.name}:"
				sts = sgn.services.sort.map do |s|
					st = check ? s.check : s.status
					puts "  #{s.name}: #{st}"
					st
				end
				return sts.count(:unmonitored) if GOD
				return RC_UP    if sts.all? { |st| st == :up   }
				return RC_DOWN  if sts.all? { |st| st == :down }
				return RC_OTHER
			else
				st = check ? sgn.check : sgn.status
				puts "#{sgn.name}: #{st}"
				if GOD
					return RC_OK if st == :up
					return RC_ERR
				else
					return RC_UP   if st == :up
					return RC_DOWN if st == :down
					return RC_OTHER
				end
			end
		end

		def do_signal(svc_or_group, sig)
			svclist = Allah.scan_services(svdir)
			return RC_TEMP if svclist.nil?

			sgn = svclist[:groups][svc_or_group] ||
					svclist[:services][svc_or_group] ||
					nil

			puts "Sending signal '#{sig}' to '#{svc_or_group}'"
			puts

			if sgn.nil?
				puts "No matching task or group"
				# Emulate weird God exit status
				GOD ? RC_OK : RC_USAGE
			else
				sgn.signal(sig) ? RC_OK : RC_ERR
			end
		end

		def do_create(svc, user, cmd)
			if svc.nil?
				puts "ERROR: No service name specified"
				return RC_ERR
			end

			if user.nil?
				puts "ERROR: No user specified"
				return RC_ERR
			end

			if cmd.nil? or cmd.empty?
				puts "ERROR: No command specified"
				return RC_ERR
			end

			unless svc =~ /^[a-z0-9_.-]+$/
				puts "ERROR: Invalid service name: #{svc}"
				return RC_ERR
			end

			gid = nil
			Etc.passwd { |p| gid = p.gid if p.name == user }

			if gid.nil?
				puts "ERROR: User #{user} does not exist"
			end

			svclist = Allah.scan_services(svdir)
			return RC_TEMP if svclist.nil?

			sgn = svclist[:groups][svc] ||
			      svclist[:services][svc] ||
			      nil

			unless sgn.nil?
				puts "ERROR: Service #{svc} already exists"
				return RC_ERR
			end

			FileUtils.mkdir_p("/var/lib/service/#{svc}/log/logs", :mode => 0750)
			FileUtils.chown(nil, gid, ["/var/lib/service/#{svc}",
			                           "/var/lib/service/#{svc}/log"])
			FileUtils.chown(user, gid, ["/var/lib/service/#{svc}/log/logs"])

			File.write("/var/lib/service/#{svc}/log/run", <<-EOF, :perm => 0740)
#!/bin/sh

exec 2>&1

exec setuidgid #{user} multilog t ./logs
EOF

			File.write("/var/lib/service/#{svc}/run", <<-EOF, :perm => 0740)
#!/bin/sh

exec 2>&1

exec setuidgid #{user} #{cmd}
EOF

			File.symlink("/var/lib/service/#{svc}", "#{svdir}/#{svc}")

			puts "Service #{svc} has been created"
			RC_OK
		end

		def do_nuke(svc)
			if svc.nil?
				puts "ERROR: No service name specified"
				return RC_ERR
			end

			svclist = Allah.scan_services(svdir)
			return RC_TEMP if svclist.nil?

			if svclist[:services][svc].nil?
				puts "ERROR: Service #{svc} does not exist"
				return RC_ERR
			end

			real_dir = File.readlink("#{svdir}/#{svc}")
			File.delete("#{svdir}/#{svc}")

			if File.directory?("#{real_dir}/log")
				Kernel.system("svc", "-kx",  "#{real_dir}/log")
			end
			Kernel.system("svc", "-kx", "#{real_dir}")

			FileUtils.rm_rf("#{real_dir}", :secure => true)

			puts "Service #{svc} has been nuked"
			RC_OK
		end

		def svdir
			dir = ENV['ALLAH_SERVICE_DIR']
			dir = '/etc/service' if dir.nil? or dir.empty?
			dir
		end

	end

	class Service
		attr_reader :name

		def initialize(svcdir)
			@svcdir = svcdir
			@name = File.basename(svcdir)
		end

		def <=>(other)
			@name <=> other.name
		end

		# Read the service's group file and return an array of all groups this
		# service is in, or an empty array if the service isn't in any groups.
		def groups
			@groups ||= begin
				File.readlines(File.join(@svcdir, 'group')).map { |g| g.strip }
			rescue Exception => e
				[]
			end
		end

		def start
			signal("UP")
		end

		def stop
			if GOD
				# god is very violent by default; allah is far more gentle, but
				# is available for smiting separately if required
				smite
			else
				signal("DOWN")
			end
		end

		def restart
			if GOD
				stop
				start
			else
				signal("TERM")
			end
		end

		def remove
			File.unlink(@svcdir)
		end

		def monitor
			signal("UP")
		end

		def unmonitor
			signal("ONCE")
		end

		def smite
			6.times { signal("DOWN"); return 0 if [:down, :unmonitored].include? status; sleep 1 }
			signal("KILL")
		end

		# Send the specified signal to the service.  Returns true
		# if the signal was delivered, or false otherwise
		def signal(sig)
			opt = case sig.upcase
				when "UP"         then '-u'
				when "DOWN"       then '-d'
				when "ONCE"       then '-o'
				when "STOP", "19" then '-p'
				when "CONT", "18" then '-c'
				when "HUP",   "1" then '-h'
				when "ALRM", "14" then '-a'
				when "INT",   "2" then '-i'
				when "TERM", "15" then '-t'
				when "KILL",  "9" then '-k'
				when "QUIT",  "3" then '-q'
				when "USR1", "10" then '-1'
				when "USR2", "12" then '-2'
				else
					puts "Unknown signal: #{sig}"
					return false
			end

			rc = Kernel.system("svc #{opt} #{@svcdir}")
			GOD ? true : rc
		end

		# Are you up, or down, or confused?
		def status
			if `svstat #{@svcdir}` =~ /: (up|down)/
				st = $1.to_sym
				st = :unmonitored if GOD and st == :down
			else
				st = :unknown
			end
			st
		end

		def check
			st = status
			return st unless st == :up

			Dir.chdir(@svcdir) do
				cmd = "./check"
				if File.file?(cmd) and File.executable?(cmd)
					st = :failed unless Kernel.system(cmd)
				end
			end

			st
		end

		def uptime
			parse_svstat
			@uptime
		end

		def pid
			parse_svstat
			@pid
		end

		def parse_svstat
			return if @uptime and @pid

			if `svstat #{@svcdir}` =~ /: up \(pid (\d+)\) (\d+) seconds/
				@pid = $1
				@uptime = $2
			end
		end

		def logfile
			Dir["#{@svcdir}/log/*/current"][0]
		end
	end

	class Group
		attr_reader :name, :services

		def initialize(name)
			@name = name
			@services = []
		end

		def <=>(other)
			@name <=> other.name
		end

		def <<(svc)
			@services << svc
		end

		def method_missing(method, *args)
			super unless [:start, :stop, :restart, :signal, :remove, :monitor, :unmonitor, :smite].include?(method)
			@services.each { |s| s.send(method, *args) }
		end
	end
end

begin
	exit Allah::CLI.new(ARGV).run if $0 == __FILE__
rescue => e
	$stderr.puts "#{e.backtrace[0]}: #{e} (#{e.class})"
	e.backtrace[1..-1].each { |bt| $stderr.puts "	from #{bt}" }
	exit! RC_TEMP
end
